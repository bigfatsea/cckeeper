#!/usr/bin/env node

/**
 * Claude Block Keeper
 * 
 * Keep Claude Code billing blocks active automatically
 * Now with proper session block detection matching ccusage logic
 * https://github.com/user/claude-keeper
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync } = require('child_process');

// Helper function to normalize timezone format
function normalizeTimezone(timezone) {
  if (!timezone) return 'UTC+8';
  const match = timezone.match(/^[Uu][Tt][Cc]([+-])(\d{1,2})$/);
  if (match) {
    const sign = match[1];
    const hours = match[2].padStart(1, '0'); // Don't pad with leading zero for single digits
    return `UTC${sign}${hours}`;
  }
  return 'UTC+8'; // Default fallback
}

// Helper function to parse timezone offset
function parseTimezoneOffset(timezone) {
  const normalized = normalizeTimezone(timezone);
  const match = normalized.match(/^UTC([+-])(\d{1,2})$/);
  if (match) {
    const sign = match[1] === '+' ? 1 : -1;
    const hours = parseInt(match[2], 10);
    return sign * hours * 60 * 60 * 1000; // Convert to milliseconds
  }
  return 8 * 60 * 60 * 1000; // Default to UTC+8 if parsing fails
}

// Helper function to format timestamp with configurable timezone
function formatTimestamp(date = new Date(), timezone = 'UTC+8') {
  // const normalizedTimezone = normalizeTimezone(timezone);
  const offset = parseTimezoneOffset(timezone);
  const adjustedDate = new Date(date.getTime() + offset);
  return adjustedDate.toISOString().slice(0, 19).replace('T', ' ');
}

// Helper function to format time only with configurable timezone
function formatTime(date, timezone = 'UTC+8') {
  const offset = parseTimezoneOffset(timezone);
  const adjustedDate = new Date(date.getTime() + offset);
  return adjustedDate.toISOString().slice(11, 16); // HH:MM format
}

// Helper function to format date and time with configurable timezone
function formatDateTime(date, timezone = 'UTC+8') {
  const offset = parseTimezoneOffset(timezone);
  const adjustedDate = new Date(date.getTime() + offset);
  const dateStr = adjustedDate.toISOString().slice(0, 10); // YYYY-MM-DD
  const timeStr = adjustedDate.toISOString().slice(11, 16); // HH:MM
  return `${dateStr} ${timeStr}`;
}

// Configuration defaults
const DEFAULT_CONFIG = {
  sessionDuration: 5 * 60 * 60 * 1000, // 5 hours in milliseconds
  claudeCommand: 'claude',              // Claude CLI command
  activationCommand: '1+1',             // Simple command to activate block
  logLevel: 'info',                     // 'silent', 'info', 'verbose'
  proxy: null,                          // Proxy URL (e.g., 'http://proxy.company.com:8080')
  forceMode: false,                     // Always activate block without checking
  timezone: 'UTC+8'                     // Timezone for datetime formatting
};

class ClaudeKeeper {
  constructor() {
    this.config = this.loadConfig();
  }

  // Load configuration from config.json or use defaults
  loadConfig() {
    const configPath = path.join(__dirname, 'config.json');
    if (fs.existsSync(configPath)) {
      try {
        const userConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        return { ...DEFAULT_CONFIG, ...userConfig };
      } catch (err) {
        this.log('warn', `Failed to load config.json: ${err.message}`);
      }
    }
    return DEFAULT_CONFIG;
  }

  // Format timestamp with configurable timezone
  formatTimestamp(date = new Date()) {
    return formatTimestamp(date, this.config.timezone);
  }

  // Format time only with configurable timezone
  formatTime(date) {
    return formatTime(date, this.config.timezone);
  }

  // Format date and time with configurable timezone
  formatDateTime(date) {
    return formatDateTime(date, this.config.timezone);
  }

  // Simple logging with timestamp
  log(level, message) {
    if (this.config.logLevel === 'silent') return;
    if (level === 'verbose' && this.config.logLevel !== 'verbose') return;
    
    const timestamp = this.formatTimestamp();
    const prefix = level === 'error' ? '❌' : level === 'warn' ? '⚠️' : 'ℹ️';
    console.log(`${timestamp} ${prefix}  ${message}`);
  }

  // Get Claude config directories
  getClaudePaths() {
    const paths = [];
    
    // Check environment variable
    const envPaths = process.env.CLAUDE_CONFIG_DIR;
    if (envPaths) {
      envPaths.split(',').forEach(p => {
        const trimmed = p.trim();
        if (trimmed && fs.existsSync(path.join(trimmed, 'projects'))) {
          paths.push(trimmed);
        }
      });
    }
    
    // Default paths
    const defaultPaths = [
      path.join(os.homedir(), '.config', 'claude'),
      path.join(os.homedir(), '.claude')
    ];
    
    defaultPaths.forEach(p => {
      if (fs.existsSync(path.join(p, 'projects')) && !paths.includes(p)) {
        paths.push(p);
      }
    });
    
    return paths;
  }

  // Recursively find all JSONL files
  findJsonlFiles(dir) {
    const files = [];
    
    const walk = (currentPath) => {
      try {
        const items = fs.readdirSync(currentPath);
        for (const item of items) {
          const fullPath = path.join(currentPath, item);
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory()) {
            walk(fullPath);
          } else if (item.endsWith('.jsonl')) {
            files.push(fullPath);
          }
        }
      } catch (err) {
        // Ignore permission errors
      }
    };
    
    walk(dir);
    return files;
  }

  // Floor timestamp to the beginning of the hour
  floorToHour(timestamp) {
    const floored = new Date(timestamp);
    floored.setUTCMinutes(0, 0, 0);
    return floored;
  }

  // Parse JSONL files and identify session blocks
  identifySessionBlocks() {
    const claudePaths = this.getClaudePaths();
    if (claudePaths.length === 0) {
      this.log('verbose', 'No Claude config directories found');
      return [];
    }

    // Find all JSONL files
    const allJsonlFiles = [];
    for (const claudePath of claudePaths) {
      const projectsPath = path.join(claudePath, 'projects');
      if (fs.existsSync(projectsPath)) {
        const files = this.findJsonlFiles(projectsPath);
        allJsonlFiles.push(...files);
      }
    }

    if (allJsonlFiles.length === 0) {
      this.log('verbose', 'No JSONL files found');
      return [];
    }

    this.log('verbose', `Found ${allJsonlFiles.length} JSONL files in ${claudePaths.length} directories`);

    // Collect all entries with timestamps
    const entries = [];
    const processedHashes = new Set();
    
    for (const file of allJsonlFiles) {
      try {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.trim().split('\n').filter(line => line);
        
        for (const line of lines) {
          try {
            const data = JSON.parse(line);
            if (data.timestamp) {
              // Create unique hash for deduplication
              const uniqueHash = data.message?.id && data.requestId 
                ? `${data.message.id}:${data.requestId}` 
                : null;
              
              // Skip duplicates
              if (uniqueHash && processedHashes.has(uniqueHash)) {
                continue;
              }
              
              if (uniqueHash) {
                processedHashes.add(uniqueHash);
              }
              
              entries.push({
                timestamp: new Date(data.timestamp),
                data: data
              });
            }
          } catch (err) {
            // Ignore invalid JSON lines
          }
        }
      } catch (err) {
        // Ignore file read errors
      }
    }
    
    if (entries.length === 0) {
      return [];
    }
    
    // Sort entries by timestamp
    entries.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    
    // Identify session blocks
    const blocks = [];
    let currentBlockStart = null;
    let currentBlockEntries = [];
    
    for (const entry of entries) {
      if (!currentBlockStart) {
        // First entry - start new block (floored to hour)
        currentBlockStart = this.floorToHour(entry.timestamp);
        currentBlockEntries = [entry];
      } else {
        const timeSinceBlockStart = entry.timestamp.getTime() - currentBlockStart.getTime();
        const lastEntry = currentBlockEntries[currentBlockEntries.length - 1];
        const timeSinceLastEntry = entry.timestamp.getTime() - lastEntry.timestamp.getTime();
        
        if (timeSinceBlockStart > this.config.sessionDuration || 
            timeSinceLastEntry > this.config.sessionDuration) {
          // Close current block
          blocks.push({
            startTime: currentBlockStart,
            endTime: new Date(currentBlockStart.getTime() + this.config.sessionDuration),
            entries: currentBlockEntries,
            actualEndTime: currentBlockEntries[currentBlockEntries.length - 1].timestamp
          });
          
          // Start new block (floored to hour)
          currentBlockStart = this.floorToHour(entry.timestamp);
          currentBlockEntries = [entry];
        } else {
          // Add to current block
          currentBlockEntries.push(entry);
        }
      }
    }
    
    // Close the last block
    if (currentBlockStart && currentBlockEntries.length > 0) {
      blocks.push({
        startTime: currentBlockStart,
        endTime: new Date(currentBlockStart.getTime() + this.config.sessionDuration),
        entries: currentBlockEntries,
        actualEndTime: currentBlockEntries[currentBlockEntries.length - 1].timestamp
      });
    }
    
    return blocks;
  }
  
  // Check if current block is active
  checkActiveBlock() {
    const blocks = this.identifySessionBlocks();
    if (blocks.length === 0) {
      return null;
    }
    
    const lastBlock = blocks[blocks.length - 1];
    const now = new Date();
    
    // Block is active if:
    // 1. Time since last activity < session duration
    // 2. Current time < block end time
    const timeSinceLastActivity = now.getTime() - lastBlock.actualEndTime.getTime();
    const isActive = timeSinceLastActivity < this.config.sessionDuration && 
                     now < lastBlock.endTime;
    
    return {
      isActive,
      lastBlock,
      timeSinceLastActivity
    };
  }

  // Activate new block by running Claude command
  activateBlock() {
    try {
      this.log('info', '🚀 Activating new block...');
      
      const command = `${this.config.claudeCommand} "${this.config.activationCommand}"`;
      this.log('verbose', `Executing command: ${command}`);
      
      // Set up environment with proxy if configured
      const env = { ...process.env };
      if (this.config.proxy) {
        env.HTTP_PROXY = this.config.proxy;
        env.HTTPS_PROXY = this.config.proxy;
        env.http_proxy = this.config.proxy;
        env.https_proxy = this.config.proxy;
        this.log('verbose', `Using proxy: ${this.config.proxy}`);
      }
      
      const output = execSync(command, { 
        encoding: 'utf8',
        timeout: 30000,
        stdio: 'pipe',
        env: env
      });
      
      // Show Claude command output if verbose or if there's actual content
      if (this.config.logLevel === 'verbose' || (output && output.trim())) {
        this.log('info', 'Claude command output:');
        console.log(output);
      }
      
      this.log('info', '✅ Block activated successfully');
      return true;
    } catch (err) {
      this.log('error', `Failed to activate block: ${err.message}`);
      
      // Show error output if available
      if (err.stdout) {
        this.log('error', 'Command stdout:');
        console.log(err.stdout);
      }
      if (err.stderr) {
        this.log('error', 'Command stderr:');
        console.log(err.stderr);
      }
      return false;
    }
  }

  // Main execution logic
  run() {
    try {
      const blockStatus = this.checkActiveBlock();
      
      if (!blockStatus) {
        this.log('info', '❌ No activity found, activating new block');
        this.activateBlock();
        return;
      }
      
      const { isActive, lastBlock, timeSinceLastActivity } = blockStatus;
      
      // Format times for display
      const activityTime = lastBlock.actualEndTime;
      const timeString = this.formatTime(activityTime);
      
      const blockStartTime = lastBlock.startTime;
      const blockStartString = this.formatTime(blockStartTime);
      
      const blockEndTime = lastBlock.endTime;
      const blockEndString = this.formatTime(blockEndTime);
      
      // Calculate remaining time in block
      const now = new Date();
      const remainingTime = blockEndTime.getTime() - now.getTime();
      const remainingMinutes = Math.max(0, Math.floor(remainingTime / (1000 * 60)));
      
      // Show block details in verbose mode
      if (this.config.logLevel === 'verbose') {
        this.log('verbose', `Block details:`);
        this.log('verbose', `  Start time: ${this.formatTimestamp(blockStartTime)}`);
        this.log('verbose', `  End time: ${this.formatTimestamp(blockEndTime)}`);
        this.log('verbose', `  Last activity: ${this.formatTimestamp(activityTime)}`);
        this.log('verbose', `  Entries in block: ${lastBlock.entries.length}`);
        this.log('verbose', `  Time since last activity: ${Math.floor(timeSinceLastActivity / (1000 * 60))} minutes`);
      }
      
      if (isActive) {
        this.log('info', `✅ Block is active (${blockStartString}-${blockEndString})`);
        this.log('info', `   Last activity: ${timeString}, ${remainingMinutes} minutes remaining`);
      } else {
        // Determine why block is not active
        if (now >= blockEndTime) {
          this.log('info', `⏰ Block expired (${blockStartString}-${blockEndString} ended)`);
        } else {
          this.log('info', `⏰ Block inactive (no activity for ${Math.floor(timeSinceLastActivity / (1000 * 60))} minutes)`);
        }
        this.log('info', `   Last activity: ${timeString}, activating new block`);
        this.activateBlock();
      }
    } catch (err) {
      this.log('error', `Execution failed: ${err.message}`);
      process.exit(1);
    }
  }
  
  // Show all session blocks
  showBlocks() {
    try {
      const blocks = this.identifySessionBlocks();
      
      if (blocks.length === 0) {
        this.log('info', 'No session blocks found');
        return;
      }
      
      this.log('info', `Found ${blocks.length} session block(s):`);
      this.log('info', '');
      
      const now = new Date();
      
      blocks.forEach((block, index) => {
        const blockNum = index + 1;
        const startTime = block.startTime;
        const endTime = block.endTime;
        const actualEndTime = block.actualEndTime;
        
        // Format times
        const startStr = this.formatDateTime(startTime);
        const endStr = this.formatTime(endTime);
        const lastActivityStr = this.formatTime(actualEndTime);
        
        // Check if block is active
        const timeSinceLastActivity = now.getTime() - actualEndTime.getTime();
        const isActive = timeSinceLastActivity < this.config.sessionDuration && now < endTime;
        
        const status = isActive ? '✅ ACTIVE' : '⏹️  EXPIRED';
        const entriesCount = block.entries.length;
        
        this.log('info', `Block #${blockNum}: ${startStr} - ${endStr} ${status}`);
        this.log('info', `          Entries: ${entriesCount}, Last activity: ${lastActivityStr}`);
        
        if (isActive) {
          const remainingTime = endTime.getTime() - now.getTime();
          const remainingMinutes = Math.max(0, Math.floor(remainingTime / (1000 * 60)));
          this.log('info', `          Remaining: ${remainingMinutes} minutes`);
        }
        
        this.log('info', '');
      });
    } catch (err) {
      this.log('error', `Failed to show blocks: ${err.message}`);
      process.exit(1);
    }
  }
}

// CLI interface
function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Claude Block Keeper - Keep Claude Code blocks active

Usage:
  claude-keeper              Check and activate if needed
  claude-keeper --force      Force activate new block
  claude-keeper -f           Force activate new block (short)
  claude-keeper --blocks     Show all session blocks
  claude-keeper --help       Show this help
  
Configuration:
  Create config.json in the same directory as this script.
  
  Example config.json:
  {
    "sessionDuration": 18000000,
    "claudeCommand": "claude",
    "activationCommand": "1+1",
    "logLevel": "info",
    "proxy": null,
    "forceMode": false,
    "timezone": "UTC+8"
  }
  
  Options:
  - sessionDuration: Block duration in milliseconds (default: 5 hours)
  - claudeCommand: Path to claude command (default: "claude")
  - activationCommand: Command to activate block (default: "1+1")
  - logLevel: "silent", "info", or "verbose" (default: "info")
  - proxy: HTTP proxy URL (default: null)
  - forceMode: Always activate without checking (default: false)
  - timezone: Timezone for datetime formatting, case insensitive (default: "UTC+8")

Usage with daemon:
  1. Download: curl -O [raw-github-url]/claude-keeper
  2. Make executable: chmod +x claude-keeper claude-keeper-daemon.sh
  3. Test: ./claude-keeper
  4. Start daemon: nohup ./claude-keeper-daemon.sh &

More info: https://github.com/user/claude-keeper
`);
    return;
  }

  const keeper = new ClaudeKeeper();
  
  // console.log('\n\n\n');
  
  // Log proxy configuration (independent of force flag)
  if (keeper.config.proxy) {
    keeper.log('info', `🌐 Proxy configured: ${keeper.config.proxy}`);
  } else {
    keeper.log('verbose', 'No proxy configured');
  }
  
  if (args.includes('--blocks')) {
    keeper.log('info', 'Claude Block Keeper - Session Blocks');
    keeper.showBlocks();
  } else {
    // Check if force mode is enabled via CLI flags or config
    const forceFromCLI = args.includes('--force') || args.includes('-f');
    const forceMode = forceFromCLI || keeper.config.forceMode;
    
    if (forceMode) {
      keeper.log('info', 'Claude Block Keeper starting (force mode)...');
      keeper.activateBlock();
    } else {
      keeper.log('info', 'Claude Block Keeper starting...');
      keeper.run();
    }
  }
}

// Helper function to get timezone for error handlers
function getTimezoneForErrors() {
  try {
    const configPath = path.join(__dirname, 'config.json');
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      return config.timezone || 'UTC+8';
    }
  } catch (err) {
    // Ignore config read errors
  }
  return 'UTC+8';
}

// Error handling
process.on('uncaughtException', (err) => {
  const timestamp = formatTimestamp(new Date(), getTimezoneForErrors());
  console.error(`[${timestamp}] ❌ Uncaught exception: ${err.message}`);
  process.exit(1);
});

process.on('unhandledRejection', (err) => {
  const timestamp = formatTimestamp(new Date(), getTimezoneForErrors());
  console.error(`[${timestamp}] ❌ Unhandled rejection: ${err}`);
  process.exit(1);
});

// Run if executed directly
if (require.main === module) {
  main();
}